### 내 풀이인척하는 풀이

- 방법 : a의 개수로 슬라이싱 윈도우를 만들고 포문으로 이동하면서 내부 b의 개수가 최소인 윈도우를 찾는다.
- 시간복잡도 : O(n)

```python
def min_swaps(word, a, b):
    num_a = word.count(a)
    num_b = word[:num_a].count(b)
    min_b = num_b

    for i in range(len(word)-num_a):
        num_b = word[i:num_a+i].count(b)
        if min_b > num_b:
            min_b = num_b

    return min_b


word = str(input())
print(min(min_swaps(word, 'a', 'b'), min_swaps(word, 'b', 'a')))
```
